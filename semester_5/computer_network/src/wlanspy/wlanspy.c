/*
 * wlanspy.c --
 *
 *      Demonstrates the usage of the libpcap API to read pcap save
 *      files. The packets are optionally filtered before the packet
 *      handler function is called to print some meta information for
 *      each filtered packet.
 *
 * Copyright (c) 2013 J. Schoenwaelder, Jacobs University Bremen
 * Copyright (c) 2002 J. Schoenwaelder, University of Osnabrueck
 */

#define _BSD_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <getopt.h>
#include <pcap.h>

static int count = 0;

static void
decode_stp(const u_char *frame, uint32_t caplen)
{
    int i;
    uint16_t bpdu_identifier, bpdu_port,
	bpdu_msg_age, bpdu_max_age, bpdu_hello, bpdu_delay;
    uint8_t bpdu_version, bpdu_type, bpdu_flags, bpdu_version_1_length;
    const uint8_t *bpdu_root, *bpdu_bridge;
    uint32_t bpdu_cost;

    /*
      2 protocol identifier
      1 protocol version
      1 BPDU type
      1 flags
      8 root identifier
      4 root path cost
      8 bridge identifier (the one sending the BPDU)
      2 port identifier (port that was used to send the BPDU)
      2 message age
      2 max age (set by the root and distributed to all bridges)
      2 hello time (time between configuration BPDUs generated by the root)
      2 forward delay (time to be used for state changes)
     */

    if (caplen >= 36) {
	bpdu_identifier = (frame[0] << 8) + frame[1];
	bpdu_version = frame[2];
	bpdu_type = frame[3];
	bpdu_flags = frame[4];
	bpdu_root = frame+5;
	bpdu_cost = (frame[13] << 24) + (frame[14] << 16)
	    + (frame[15] << 8) + frame[16];
	bpdu_bridge = frame+17;
	bpdu_port = (frame[25] << 8) + frame[26];
	bpdu_msg_age = (frame[27] << 8) + frame[28];
	bpdu_max_age = (frame[29] << 8) + frame[30];
	bpdu_hello = (frame[31] << 8) + frame[32];
	bpdu_delay = (frame[33] << 8) + frame[34];
	if (bpdu_version == 0x02) {
	    /* Rapid Spanning Tree */
	    bpdu_version_1_length = frame[35];
	}

	printf(" stp.identifier=0x%04x", bpdu_identifier);
	printf(" stp.version=0x%02x", bpdu_version);
	printf(" stp.type=0x%02x", bpdu_type);
	printf(" stp.flags=0x%02x", bpdu_flags);
	printf(" stp.root=");
	for (i = 0; i < 8; i++) {
	    printf("%s%02X", i ? ":" : "", bpdu_root[i]);
	}
	printf(" stp.root.cost=%d", bpdu_cost);
	printf(" stp.bridge=");
	for (i = 0; i < 8; i++) {
	    printf("%s%02X", i ? ":" : "", bpdu_bridge[i]);
	}
	printf(" stp.port=%d", bpdu_port);
	printf(" stp.msg_age=%.3f", bpdu_msg_age/256.0);
	printf(" stp.max_age=%.3f", bpdu_max_age/256.0);
	printf(" stp.hello=%.3f", bpdu_hello/256.0);
	printf(" stp.forward=%.3f", bpdu_delay/256.0);
	if (bpdu_version == 0x02) {
	    printf(" stp.versionlength=%d", bpdu_version_1_length);
	}
    } else {
        printf(" [|stp]");
    }
}

static void
decode_llc(const u_char *frame, uint32_t caplen)
{
    uint8_t dsap, ssap, ctrl;

    if (caplen > 3) {
	dsap = frame[0];
	ssap = frame[1];
	ctrl = frame[2];
	printf(" llc.dsap=0x%02x", dsap);
	printf(" llc.ssap=0x%02x", ssap);
	printf(" llc.ctrl=0x%02x", ctrl);	
	if (dsap == 0x42 && ssap == 0x42) {
	    decode_stp(frame+3, caplen-3);
	}
    } else {
        printf(" [|llc]");
    }
}

static void
decode_ether(const u_char *frame, uint32_t caplen)
{
    int i;
    uint16_t type;

    if (caplen < 14) {
        printf(" [|ether]");
        return;
    }

    printf(" eth.dst=");
    for (i = 0; i < 6; i++) {
	printf("%s%02x", i ? ":" : "", frame[i]);
    }

    printf(" eth.src=");
    for (i = 0; i < 6; i++) {
	printf("%s%02x", i ? ":" : "", frame[i+6]);
    }

    type = (frame[12] << 8) + frame[13];

    if (type <= 1500) {
	if (caplen < 16) {
	    printf(" [|ether]");
	    return;
	}
	printf(" eth.len=%d", type);
	if (frame[14] == 0xaa && frame[15] == 0xaa) {
	    /* IEEE 802.2 SNAP */
	} else if (frame[14] == 0xff && frame[15] == 0xff) {
	    /* Novell raw IEEE 802.3 */
	} else {
	    /* IEEE 802.2 LLC */
	    decode_llc(frame+14, caplen-14);
	}
	
    } else if (type >= 1536) {
	/* Ethernet II */
	printf(" eth.type=%02x", type);
#if 1
	switch (type) {
	case 0x800:
	    printf(" IPv4");
	    break;
	case 0x806:
	    printf(" ARP");
	    break;
	case 0x86DD:
	    printf(" IPv6");
	    break;
	default:
	    break;
	}
#endif
    }
}

static void
decode_wlan_beacon(const u_char *frame, uint32_t caplen)
{
    int i;
    uint64_t timestamp;
    uint16_t interval;
    uint16_t capabilities;

    if (caplen < 12) {
        printf(" [|wlan beacon]");
	return;
    }

    timestamp = 0;
    for (i = 0; i < 8; i++) {
	timestamp = (timestamp << 8) + frame[i];
    }
    interval = (frame[8] << 8) + frame[9];
    capabilities = (frame[10] << 8) + frame[11];

    printf(" wlan.beacon.timestamp=%lld wlan.beacon.interval=%d wlan.beacon.capabilities=0x%04x", 
	   timestamp, interval, capabilities);
}

static void
decode_wlan(const u_char *frame, uint32_t caplen)
{
    int i;
    uint16_t fc;
    uint16_t duration;
    uint16_t sequence;

    if (caplen < 30) {
        printf(" [|wlan]");
	return;
    }

    fc = (frame[0] << 8) + frame[1];
    duration = (frame[2] << 8) + frame[3];
    sequence = (frame[22] << 8) + frame[23];
    printf(" wlan.fc=0x%04x wlan.duration=0x%04x wlan.sequence=0x%04x", 
	   fc, duration, sequence);

    printf(" wlan.addr1=");
    for (i = 0; i < 6; i++) {
	printf("%s%02x", i ? ":" : "", frame[i+4]);
    }

    printf(" wlan.addr2=");
    for (i = 0; i < 6; i++) {
	printf("%s%02x", i ? ":" : "", frame[i+10]);
    }

    printf(" wlan.addr3=");
    for (i = 0; i < 6; i++) {
	printf("%s%02x", i ? ":" : "", frame[i+16]);
    }

    printf(" wlan.addr4=");
    for (i = 0; i < 6; i++) {
	printf("%s%02x", i ? ":" : "", frame[i+24]);
    }

    if ((fc & 0xff00) == 0x8000) {
	decode_wlan_beacon(frame+30, caplen-30);
    }

#if 0
    fprintf(stderr, "decode_wlan:\n");
#endif
}

static void
decode_radiotap(const u_char *frame, uint32_t caplen)
{
    uint8_t version;
    uint8_t pad;
    uint16_t len;
    uint32_t present;

    if (caplen < 8) {
        printf(" [|radiotap]");
        return;
    }

    version = frame[0];
    pad = frame[1];
    len = (frame[3] << 8) + frame[2];
    present = (frame[4] << 24) + (frame[5] << 16) + (frame[6] << 8) + frame[7];
    printf(" radiotap.version=%d"
	   " radiotap.pad=0x%02x"
	   " radiotap.len=%d"
	   " radiotap.present=0x%04x", version, pad, len, present);

    if (len > caplen) {
        printf(" [|radiotap]");
	return;
    }

    decode_wlan(frame+len, caplen-len);
}

static void
handler(u_char *user, const struct pcap_pkthdr *pkthdr, const u_char *data)
{
    pcap_t *pc = (pcap_t *) user;
    int link;

    link = pcap_datalink(pc);
    count++;
    printf("frame.number=%d frame.time=%lu.%06lds "
	   "frame.cap_len=%d frame.len=%d", // tv_usec is a suseconds_t which
	    count, pkthdr->ts.tv_sec,       // is usually a signed long. Except
	    (long)pkthdr->ts.tv_usec,       // on sparc where it's a signed int
	    pkthdr->caplen, pkthdr->len);

    switch (link) {
    case DLT_EN10MB:
	decode_ether(data, pkthdr->caplen);
	break;
    case DLT_IEEE802_11_RADIO:
        decode_radiotap(data, pkthdr->caplen);
        break;
    default:
	fprintf(stderr, "wlanspy: unable to handle data link type %d\n", link);
	break;
    }

    printf("\n");
}

int
main(int argc, char **argv)
{
    char ebuf[PCAP_ERRBUF_SIZE];
    pcap_t *pc;
    int opt, code;
    char *interface = NULL, *filter = NULL, *file = NULL;
    const char usage[] = "usage: wlanspy [-i interface] [-f filter] [<file>]";

    if (argc < 1 || argc > 3) {
        fprintf(stderr, "%s\n", usage);
        exit(EXIT_FAILURE);
    }

    while ((opt = getopt(argc, argv, "i:f:")) != -1) {
	switch (opt) {
	case 'f':
	    filter = optarg;
	    break;
	case 'i':
	    interface = optarg;
	    break;
	default:
	    fprintf(stderr, "%s\n", usage);
	    exit(EXIT_FAILURE);
	}
    }

    if (optind < argc) {
	file = argv[optind];
    }

    if (file && interface) {
	fprintf(stderr, "wlanspy: Input file and live capture interface"
		" cannot be specified at the same time.\n");
	fprintf(stderr, "%s\n", usage);
	exit(EXIT_FAILURE);
    }

    if (! file && ! interface) {
	/*
	 * Newer libpcap versions accept a NULL interface as an any
	 * interface but older versions simply crash with a
	 * segmentation fault. Any interfaces come with their own sort
	 * of problems since the data link type may be faked.  Hence,
	 * we don't do anything if the user did not specify a data
	 * source.
	 */
	exit(EXIT_SUCCESS);
    }

    if (interface) {
	pc = pcap_create(interface, ebuf);
	if (! pc) {
	    fprintf(stderr, "wlanspy: failed to open interface: %s\n", ebuf);
	    exit(EXIT_FAILURE);
	}
	(void) pcap_set_promisc(pc, 1);
	code = pcap_activate(pc);
	switch (code) {
#ifdef PCAP_WARNING_TSTAMP_TYPE_NOTSUP
	case PCAP_WARNING_TSTAMP_TYPE_NOTSUP:
	    fprintf(stderr, "wlanspy: pcap: timestamp type not supported\n");
	    break;
#endif
	case PCAP_ERROR_ACTIVATED:
	    fprintf(stderr, "wlanspy: pcap: handle already activated\n");
	    exit(EXIT_FAILURE);
#ifdef PCAP_ERROR_PROMISC_PERM_DENIED
	case PCAP_ERROR_PROMISC_PERM_DENIED:
	    fprintf(stderr, "wlanspy: pcap: promiscuous mode denied\n");
	    exit(EXIT_FAILURE);
#endif
	case PCAP_ERROR_RFMON_NOTSUP:
	    fprintf(stderr, "wlanspy: pcap: monitor mode not supported\n");
	    exit(EXIT_FAILURE);
	case PCAP_ERROR_IFACE_NOT_UP:
	    fprintf(stderr, "wlanspy: pcap: interface not supported\n");
	    exit(EXIT_FAILURE);
 	case PCAP_WARNING_PROMISC_NOTSUP:
	case PCAP_WARNING:
	    fprintf(stderr, "wlanspy: pcap: %s\n", pcap_geterr(pc));
	    break;
	case PCAP_ERROR_NO_SUCH_DEVICE:
	case PCAP_ERROR_PERM_DENIED:
	case PCAP_ERROR:
	    fprintf(stderr, "wlanspy: pcap: %s\n", pcap_geterr(pc));
	    exit(EXIT_FAILURE);
	}
    } else {
	pc = pcap_open_offline(file, ebuf);
	if (! pc) {
	    fprintf(stderr, "wlanspy: failed to open file: %s\n", ebuf);
	    exit(EXIT_FAILURE);
	}
    }

    if (filter) {
        struct bpf_program bpf;
        if (pcap_compile(pc, &bpf, filter, 1, 0) == -1) {
            fprintf(stderr, "wlanspy: failed to compile filter: %s\n",
		    pcap_geterr(pc));
            exit(EXIT_FAILURE);
        }
        if (pcap_setfilter(pc, &bpf) == -1) {
            fprintf(stderr, "wlanspy: failed to set filter: %s\n",
		    pcap_geterr(pc));
            exit(EXIT_FAILURE);
        }
    }

    if (pcap_loop(pc, -1, handler, (u_char *) pc) == -1) {
        fprintf(stderr, "wlanspy: failed to process packets: %s\n",
		pcap_geterr(pc));
        exit(EXIT_FAILURE);
    }

    pcap_close(pc);
    return EXIT_SUCCESS;
}
